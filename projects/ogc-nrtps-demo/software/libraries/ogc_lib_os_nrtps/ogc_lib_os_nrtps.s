;
; File generated by cc65 v 2.19 - Git c226e58
;
	.fopt		compiler,"cc65 v 2.19 - Git c226e58"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.export		_ogc_lib_os_nrtps_init
	.export		_ogc_lib_os_nrtps_set
	.export		_ogc_lib_os_nrtps_clear
	.export		_ogc_lib_os_nrtps_start
	.export		_ogc_lib_os_nrtps_end
	.import		_hal_get_sys_tick
	.export		_event_array

.segment	"DATA"

_event_array:
	.byte	$00
	.dword	$00000000
	.word	$0000
	.word	$0000
	.res	36,$00

; ---------------------------------------------------------------
; void __near__ ogc_lib_os_nrtps_init (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ogc_lib_os_nrtps_init: near

.segment	"CODE"

;
; uint8_t init_index = 0U;
;
	lda     #$00
	jsr     pusha
;
; for ( ; init_index < OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE; init_index++ )
;
	tay
L0007:	lda     (sp),y
	cmp     #$05
	bcs     L0001
;
; event_array[ init_index ].status = E_OGC_LIB_OS_NRTPS_EVENT__EMPTY;
;
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	tya
	sta     (ptr1),y
;
; event_array[ init_index ].timestamp = 0U;
;
	tax
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	tay
	txa
	adc     #>(_event_array)
	tax
	tya
	jsr     pushax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	txa
	ldy     #$01
	jsr     steaxspidx
;
; event_array[ init_index ].callback_function = NULL;
;
	lda     (sp,x)
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	lda     #$00
	ldy     #$05
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; event_array[ init_index ].argument_pointer = NULL;
;
	tax
	lda     (sp,x)
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	lda     #$00
	iny
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; for ( ; init_index < OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE; init_index++ )
;
	tay
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
	jmp     L0007
;
; }
;
L0001:	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; enum e_ogc_lib_os_nrtps_status __near__ ogc_lib_os_nrtps_set (unsigned long task_period_tick, void (*function)(void *), void *arguments)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ogc_lib_os_nrtps_set: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; uint8_t set_index = 0U;
;
	lda     #$00
	jsr     pusha
;
; for ( ; set_index < OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE; set_index++ )
;
	tay
L000A:	lda     (sp),y
	cmp     #$05
	jcs     L0003
;
; if ( E_OGC_LIB_OS_NRTPS_EVENT__EMPTY == event_array[ set_index ].status )
;
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	sta     ptr1
	txa
	clc
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #<(_event_array)
	lda     (ptr1),y
	jne     L0004
;
; event_array[ set_index ].status = E_OGC_LIB_OS_NRTPS_EVENT__PENDING;
;
	tay
	tax
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	lda     #$01
	sta     (ptr1),y
;
; event_array[ set_index ].timestamp = hal_get_sys_tick() + task_period_tick;
;
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	tay
	txa
	adc     #>(_event_array)
	tax
	tya
	jsr     pushax
	jsr     _hal_get_sys_tick
	jsr     pusheax
	ldy     #$0E
	jsr     ldeaxysp
	jsr     tosaddeax
	ldy     #$01
	jsr     steaxspidx
;
; event_array[ set_index ].callback_function = function;
;
	ldx     #$00
	lda     (sp,x)
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$05
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; event_array[ set_index ].argument_pointer = arguments;
;
	ldx     #$00
	lda     (sp,x)
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$07
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; if ( set_index < ( OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE - 1U ) )
;
	ldx     #$00
	lda     (sp,x)
	cmp     #$04
	bcs     L000B
;
; return ( E_OGC_LIB_OS_NRTPS_STATUS__OCCUPIED );
;
	lda     #$01
	jmp     L0001
;
; return ( E_OGC_LIB_OS_NRTPS_STATUS__FULL );
;
L000B:	lda     #$02
	jmp     L0001
;
; for ( ; set_index < OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE; set_index++ )
;
L0004:	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
	jmp     L000A
;
; return ( E_OGC_LIB_OS_NRTPS_STATUS__FAILURE );
;
L0003:	ldx     #$FF
	txa
;
; }
;
L0001:	ldy     #$09
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; enum e_ogc_lib_os_nrtps_status __near__ ogc_lib_os_nrtps_clear (void (*function)(void *), void *arguments)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ogc_lib_os_nrtps_clear: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; bool task_found = false;
;
	lda     #$00
	jsr     pusha
;
; uint8_t clear_index = 0U;
;
	jsr     pusha
;
; for ( ; clear_index < OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE; clear_index++ )
;
	tay
L000D:	lda     (sp),y
	cmp     #$05
	jcs     L000F
;
; if ( ( E_OGC_LIB_OS_NRTPS_EVENT__PENDING == event_array[ clear_index ].status )
;
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	sta     ptr1
	txa
	clc
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #<(_event_array)
	lda     (ptr1),y
	cmp     #$01
;
; && ( function == event_array[ clear_index ].callback_function )
;
	jne     L0004
	ldy     #$07
	jsr     pushwysp
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #$06
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     tosicmp
;
; && ( arguments == event_array[ clear_index ].argument_pointer )
;
	jne     L0004
	ldy     #$05
	jsr     pushwysp
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #$08
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     tosicmp
;
; )
;
	bne     L0004
;
; event_array[ clear_index ].status = E_OGC_LIB_OS_NRTPS_EVENT__EMPTY;
;
	ldy     #$00
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	tya
	sta     (ptr1),y
;
; event_array[ clear_index ].timestamp = 0U;
;
	tax
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	tay
	txa
	adc     #>(_event_array)
	tax
	tya
	jsr     pushax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	txa
	ldy     #$01
	jsr     steaxspidx
;
; event_array[ clear_index ].callback_function = NULL;
;
	lda     (sp,x)
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	lda     #$00
	ldy     #$05
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; event_array[ clear_index ].argument_pointer = NULL;
;
	tax
	lda     (sp,x)
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	lda     #$00
	iny
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; task_found = true;
;
	lda     #$01
	tay
	sta     (sp),y
;
; for ( ; clear_index < OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE; clear_index++ )
;
L0004:	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
	jmp     L000D
;
; if ( true == task_found )
;
L000F:	lda     #$01
	iny
	cmp     (sp),y
	bne     L000A
;
; return ( E_OGC_LIB_OS_NRTPS_STATUS__EMPTY );
;
	ldx     #$00
	jmp     L0010
;
; return ( E_OGC_LIB_OS_NRTPS_STATUS__FAILURE );
;
L000A:	ldx     #$FF
L0010:	txa
;
; }
;
	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ ogc_lib_os_nrtps_start (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ogc_lib_os_nrtps_start: near

.segment	"CODE"

;
; uint8_t start_index = 0U;
;
	lda     #$00
	jsr     pusha
;
; while ( start_index < OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE )
;
	jmp     L000A
;
; if ( ( E_OGC_LIB_OS_NRTPS_EVENT__PENDING == event_array[ start_index ].status )
;
L0002:	ldx     #$00
	lda     (sp,x)
	jsr     mulax9
	sta     ptr1
	txa
	clc
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #<(_event_array)
	lda     (ptr1),y
	cmp     #$01
;
; && ( event_array[ start_index ].timestamp < hal_get_sys_tick() )
;
	jne     L0005
	ldx     #$00
	lda     (sp,x)
	jsr     mulax9
	clc
	adc     #<(_event_array)
	tay
	txa
	adc     #>(_event_array)
	tax
	tya
	ldy     #$04
	jsr     ldeaxidx
	jsr     pusheax
	jsr     _hal_get_sys_tick
	jsr     tosulteax
;
; )
;
	jeq     L0005
;
; if ( NULL != event_array[ start_index ].callback_function )
;
	jsr     push0
	ldy     #$02
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #$06
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     tosicmp
	beq     L0009
;
; event_array[ start_index ].callback_function( event_array[ start_index ].argument_pointer );
;
	ldx     #$00
	lda     (sp,x)
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #$06
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	ldy     #$08
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	pha
	ldy     #$00
	lda     (sp),y
	sta     jmpvec+1
	iny
	lda     (sp),y
	sta     jmpvec+2
	pla
	jsr     jmpvec
	jsr     incsp2
;
; event_array[ start_index ].status = E_OGC_LIB_OS_NRTPS_EVENT__EMPTY;
;
L0009:	ldy     #$00
	ldx     #$00
	lda     (sp),y
	jsr     mulax9
	clc
	adc     #<(_event_array)
	sta     ptr1
	txa
	adc     #>(_event_array)
	sta     ptr1+1
	tya
	sta     (ptr1),y
;
; start_index++;
;
L0005:	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; if ( OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE == start_index )
;
	lda     #$05
	cmp     (sp),y
	bne     L000D
;
; start_index = 0U;
;
	tya
	sta     (sp),y
;
; while ( start_index < OGC_LIB_OS_NRTPS__EVENT_ARRAY_SIZE )
;
L000A:	tay
L000D:	lda     (sp),y
	cmp     #$05
	jcc     L0002
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ ogc_lib_os_nrtps_end (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ogc_lib_os_nrtps_end: near

.segment	"CODE"

;
; }
;
	rts

.endproc

